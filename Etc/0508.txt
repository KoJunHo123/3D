0508
솔루션 -> 프로젝트(Win32)

폴더
Bin : 2진화된 파일들 저장.(dat, exe...) -> 실행을 위한 모든 파일. 이것만 있어도 실행은 가능하도록.
1. 파일 입출력용 파일
2. 텍스쳐 파일...
3. exe 파일...

***
구동 코드 : 코드의 흐름을 만들어주는 코드. 진입점 함수를 호출함(main). 컴파일러가 만들어줌.
내가 짠 코드 모음(obj) + 구동 코드 = exe. -> 전부 이진화 되어 있음. -> bin 파일에 넣음.
***	

Default : 프로젝트 만들었을 때 기본적으로 만들어지는 놈들. 더러우니까.
Private : 보여주기 싫은 파일들.(cpp 파일)
Public : 보여주는 파일(h 파일)

솔루션이 프로젝트를 참조. -> 프로젝트 위치 바뀌면 안됨.
-> 바꼈을 경우 지우고 기존 프로젝트 불러오기로 다시 불러와야 함.
vcxproj : 프로젝트를 대표하는 파일.

64비트.
속성-> 모든구성.(디버그, 릴리즈 둘 다 적용.)
출력 디렉터리 : 빌드한 결과 저장 위치 -> bin에 저장.
경로의 마지막이 폴더의 이름이면 \ 붙이기.(기본 소양)

도구 -> 설정 가져오기 및 내보내기 -> 모두 다시 설정 -> 아니요 -> visual C++ -> 마침 (단축키가 다름)

클래스 만들 때.../Public/MainApp.h -> 한번에 폴더로 옮기면서 생성 가능.

생성자, 소멸자는 private or protected로만

public 변수를 쓰면 안되는 이유 : 
Get, Set도 좀 자제해라.
자식이 부모 멤버 변수 쓰는 것도 자제하자.

구조체 : 데이터 타입에 초점. -> 데이터를 모아두기 위함이라고 봐야 함.
클래스 : 기능에 초점. -> 함수를 모아두기 위함이라고 봐야 함. -> 함수의 기능을 수행하기 위한 변수.

변수를 불러올 때는 항상 고민해보기. 
과연 여기서 만들어야 하는가? 
부모 -> 자식 또한 마찬가지.
안꺼내오고 짜는 것을 반복하면 클래스의 기능이 많아짐 -> 모듈화가 됨.

static 멤버 함수의 특징 ->  객체를 선언하지 않아도 선언할 수 있는 멤버 함수
1. this 포인터를 사용하지 못함
2. 멤버 변수, 멤버 함수를 호출하지 못함.

소멸자 = default ; -> 소멸자(){}; 랑 같은 놈. 가독성 증가용!

Peek : 엿보다.

추상 클래스 : 클래스를 객체화 할 수 없음.
-> 절대 독립적으로는 객체화 될 수 없음. (부모로서는 객체화 불가능.)
-> 부모면 일단 abstract 붙이고 보자. 안햇갈리게.

레퍼런스 카운트 : 몇개의 객체에 참조되고 있는가. (몇개의 포인터가 나의 주소를 갖고 있는가.)

스마트 포인터 안쓰고 CBase 왜 씀...?
-> 클레스를 객체화 했을 때 레퍼런스 카운트 기능을 강제하고 싶어서.
-> COM 객체의 구조를 흉내냈음.

객체에 따른 삭제 방법을 고정. 모든 클래스의 삭제 방법.
-> Safe_Release();

일반적인 데이터 타입(Struct)
-> Safe_Delete();







